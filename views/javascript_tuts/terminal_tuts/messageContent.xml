<?xml version="1.0" encoding="UTF-8"?>
 <chapters>
 <chapter>
   <subject>history</subject>
    <content>
   <subtitle></subtitle>
    <paragraph>
        <info>bash_history is the file that keeps track of the commands U have ever entered</info>
        <example>
        ---------- history commands ---------

        //all history logged since U start using terminal with correspodind number
        history 

        //narow down to prase
        history | grep redis

        //execute history corresponding number
        !34 (number logged in history command);

        //delete sesion history 
        history -c

        //delete all history 
        rm ~/.bash_history

        //look for command recursively 
        ctrl+R

        //update command in history change one command for another
        history | grep dnf (look for dnf)

        //now look for ssh
        ^dnf^ssh^ (find me dnf command and swap to ssh)

        </example>
    </paragraph>
  </content>
  </chapter>
  <chapter>
      <subject>file permisions</subject>
      <content>
      <subtitle>find it out the user (either root or any other user)</subtitle>
      <paragraph>
          <info>
           Linux can have eiher a regual user of super user(su) which is root
          </info>
          <example>
/*********************************************/

  //to find out who is logged in;
    whoami  
      //prints greggil

  //to change to root (super user);
      sudo su - 
      //whoami prints root;

  //to chage back to regular user
      su - greggil
      //whoami prints root;


/*********************************************/
          </example>
      </paragraph>
      <subtitle>changing the owner of the file/directory</subtitle>
      <paragraph>
          <info>depending who created file/directory (which user) and only that user can maninpulate (edit/delete)
          unless you will change file/directory permisions;</info>
          <example>
/*********************************************/

//if the owner of the file is root then only root can change its owner 

//change from root to gilg  (subdirectories stile belong to root)

  sudo chown gilg file/directory;

//change owner from root to gilg for file/direcoires with all subdirectories -R flag now belong to gilg

sudo chown -R gilg file/directory/subdirectory;

/*********************************************/
          </example>
      </paragraph>
    </content>
  </chapter>
   <chapter>
       <subject>change file permisions</subject>
       <content>
           <paragraph>
               <info>file/directory permisions can be eiher drwx = directory,read,write,execute that could be also stated in numeric

0 = ---
1 = --x
2 = -w-
3 = -wx
4 = r-
5 = r-x
6 = rw-
7 = rwx 

</info>
               <example>
---------------- add or remove file permision for owner---------------------

//adds read/write/execute for the owner 
chmod +rwx; = chmod u+rwx; (user is owner by default)

//removes read/write/execute for the owner 
chmod +rwx = chmod u+rwx;

---------------- add or remove file permision for owner and group---------------------

//adds read/write/execute for the owner and the group
chmod ug+rwx;
//removes read/write/execute for the owner and the group
chmod og-rwx;

---------------- add or remove file permision for owner and group and others---------------------

//adds read/write/execute for the owner and the group and the others
chmod ugo+rwx = chmod 777;
//removes read/write/execute for the owner and the group and the others
chmod ugo-rwx;

------------ ------------ ------------ ------------
              </example>
           </paragraph>
       </content>
   </chapter>
   <chapter>
       <subject>find</subject>
       <content>
          <subtitle>find general pattern</subtitle>
           <paragraph>
               <info>
               The find command will begin looking:
               in the starting directory you specify and proceed to search through 
               all accessible subdirectories. 
               You may specify more than one starting directory for searching.
               
               find (starting directory) (matching criteria and actions);
               </info>
               <example>
------------ ------------  general search --------  ------------

------- find in directory (/ slash means root directory be aware ./ dot means current)------------
 find ./directory/ -name 'filename' or '*wilcardCombination'

--------------- u should always use find with flags (more predictable)------------ 
//find all files in given directory (recursively);
find ./scripts -type f

//find all directories in given directory (recursively);
find ./scripts -type d

//find recursively from current all js files that have name as wilcardCombination 
-name 'filename or *wilcardCombination' flag
 find ./directory/ -name '*.js'

 //find recursively more that one directory at the time that have files
 find ./directory/ ./directory1/ -type f

//combining flags (all files that size is bigger thant 1000mb and -name '*.js')
-type f =all files
-size +1 = bigger than 1mb
-print = print paths
 -name '*.js 

find ./scripts -type f -size +1000 -print -name '*.js
               </example>
           </paragraph>
           <subtitle>find with exclusion !(not operator)</subtitle>
           <paragraph>
               <info>U can perform your search and specify what to exclude from search 
               as !exclude with flag
               we will operate on those flags:

                ! === --not (selector)
                -path '/*' (selector)
                -o (logical or)
                -prune => means exclude ussually in combination with -o 
                [ -o -path './node_modules' -prune ] => or exclude

               </info>
               <example>

 --------------- exclude with !(not) or -not selector ------------ 

//find all files in given directory (recursively) and exclude .txt files
// find ./to_delete/ -type f => look for files -type f
//! -name '*.txt' => but not ones of .txt extension

find ./to_delete/ -type f ! -name '*.txt'



//find index.* but exclude node_modules -path flag
//find . -name 'index.*' => look for index.*
//! -path '*/node*' => but exclude node*

find . -name 'index.*' ! -path '*/node*'

//the same as above with -not selector !=== -not

find . -name 'index*' -not -path './node_modules/*'

//exclude multiple directories with -path (path has to have wild cards dir/* )
//. ! -path './node_modules/*' => exclude from node_modules/*
//. ! -path './constants/*' => exclude from constants/*
//-iname "index*" => finally look for index.* name elsewhere

find . ! -path './node_modules/*' ! -path './constants/*' -iname "index*"

//the same as above with -not selector !=== -not

find . -name 'index*' -not -path './node_modules/*' -not -path './constants/*

//or more mathematic approach (too complex but proves the magic of maths)
find . -name 'index*' -not \( -path './node_modules/*' -o -path './vendor/*' \)


------------   exclude with -prune flag and -o (or selector) -------------------

//-path './node_modules' -prune => exclude ./node_modules
// -o -iname 'index*' => or show case insensitive for name 'index*'
// -print => dont show paths where perform search; 

find . -path './node_modules' -prune -o -type f -iname 'index*' -print
//reverse above
find . -type f -iname 'index*' -print -o -path './node_modules' -prune 
 ------------------------------------------------------------

               </example>
           </paragraph>
           <subtitle>pipe find results</subtitle>
           <paragraph>
               <info>pipe allows you to combine your commands and take results from command into another and another
               findResults (| pipe into) deleteCommand

               IMPORTANT: pipe always need verb after like: grep or xargs ...
                </info>
               <example>
  ----------------- find files then filter and delete them  -----------------

  //lets assume U have file1.js, file2.js , file3.js, file4.js 
  //and U want to remove only files 2 and 3 you can find all, pipe to filter and remove

  find file*.js | grep "file[2-3]" | xargs rm


  --------------------------------------------------------------------
                 
               </example>
           </paragraph>
       </content>
   </chapter>
   <chapter>
       <subject>Desctructuring Assigment in Arrays</subject>
       <content>
          <subtitle>Desctructuring Assigment in Arrays</subtitle>
           <paragraph>
               <info>Desctructuring Assigment in Arrays:
               allows you to assign "=" left to right with desctructuring syntax by creating variables as 

               let [pocket1, pocket2, pocket3] = [1,2,3];

               </info>
               <example>
 ------------------- ES5 -------------------

 var someArray = [1, 2, 3];
 var first = someArray[0];
 var second = someArray[1];
 var third = someArray[2];

 ------------------- ES6 -------------------

 var someArray = [1, 2, 3];
 let [pocket1, pocket2, pocket3] = someArray;
 console.log(pocket1, pocket2, pocket3);

 ----------------U can also skip values cause U can not be asked to type so much ;) -------------

 let  [,,third] = ["foo", "bar", "baz"];
 console.log(third); // "baz"

 -----------------------
             </example>
           </paragraph>
           <subtitle>Desctructuring Assigment in nested structure Arrays</subtitle>
           <paragraph>
               <info>let [foo, [[bar], baz]] = [1, [[2], 3]]; //the [] syntax has to match;
               </info>
               <example>

 ----------------------ES6--------------------------

 var [foo, [[bar], baz]] = [1, [[2], 3]]; //the [] syntax has to match;
 console.log('values', foo,bar,baz);

 --------------------------------------------------
             </example>
           </paragraph>
            <subtitle>Desctructuring Assigment in Arrays with (Spread Operator)</subtitle>
           <paragraph>
               <info>Desctructuring Assigment in Arrays with (Spread Operator)</info>
               <example>

-------------- selecting last element of hte array with spread operator -------------------

var [head, ...tail] = [1, 2, 3, 4];
console.log(tail);// [2, 3, 4]
console.log(head);// 1

------------------------------------------------------------------------------------------

             </example>
            </paragraph>
            <subtitle>Desctructuring Assigment in Arrays with (default value)</subtitle>
              <paragraph>
               <info>Desctructuring Assigment in Arrays (default value) can be assign to your desctucring structure to avoid undefined value</info>
               <example>

 -------------------------- when the value doesnt exist -------------------------- 

 var [missing] = [];
 console.log(missing);
 // undefined

 -------------------------- but you can specify a default value as solution  -------------------------- 

 var [missing = true] = [];
 console.log(missing); //true;

 -------------------------- -------------------------- -------------------------- -------------------------- 

             </example>
            </paragraph>
       </content>
   </chapter>

   <chapter>
       <subject>Array.prototype.splice(startIndex,[endIndex])</subject>
       <content>
         <subtitle>Array.prototype.splice(startIndex,[endIndex])</subtitle>
           <paragraph>
               <info>Array.prototype.splice(startIndex,[endIndex])
                    it will create a new Array from original one from startIndex [endIndex, 'newValue'] and it will modify the original
               </info>
               <example>
-------------------------- array --------------------------

  const months = ['Jan', 'March', 'April', 'June'];

 -------------------------- months.splice(2) --------------------------

  const cutHalf = months.splice(2);
  //cutHalf = ['April', 'June']; 
  //months = ['Jan', 'March']; 

  -------------------------- Array.prototype.splice(startIndex,endIndex) --------------------------

  const months = ['Jan', 'March', 'April', 'June'];

  const cutMiddle = months.splice(1,2);
  //cutMiddle = ['March', 'April']; 
  //months = ['Jan', 'June'];

  ------------------------- ------------------------- ------------------------- 

               </example>
           </paragraph>
       <subtitle>Array.prototype.splice(startIndex,[endIndex,replacedRangeInSplice]</subtitle>
           <paragraph>
               <info>Array.prototype.splice(startIndex,[endIndex,replacedRangeInSplice])
      
                    the third argument will replace splice chunk (startIndex,endIndex) with the third Argument
               </info>
               <example>
 -------------------------- array --------------------------
  const months = ['Jan', 'March', 'April', 'June'];

   -------------------------- Array.prototype.splice(startIndex,endIndex) --------------------------

  const cutMiddle = months.splice(1,2,'replacedRangeInSplice');

  //cutMiddle = ['March', 'April']; 
  //months = ['Jan', 'replacedRangeInSplice', 'June'];


   -------------------------- -------------------------- -------------------------- --------------------------
               </example>
           </paragraph>
       <subtitle>Array.prototype.splice(-1)</subtitle>
           <paragraph>
               <info>Array.prototype.splice(-1)
                    splicing from the tail of the array so last element and create an array of the last one;
              </info>
               <example>
  -------------------------- array --------------------------

  const months = ['Jan', 'March', 'April', 'June','July', 'August'];

  -------------------------- const lastElement = months.splice(-1)  --------------------------

  const lastElement = months.splice(-1)
  //lastElement = ['August'];
  //months = ['Jan', 'March', 'April', 'June','July'];

   --------------------------  --------------------------  --------------------------  -------------------------- 
               </example>
           </paragraph>
       <subtitle>Array.prototype.splice(-1,1,replaceLastfromOriginal)</subtitle>
           <paragraph>
               <info>
                Array.prototype.splice(-1,1,replaceLastfromOriginal)
                 /*splicing from the tail of the array and replace original last element array*/

                 Array.prototype.splice(startIndex,lastIndex,'replace') lastindex has to be 1 any other number will produce unexpexted results

               </info>
               <example>
 -------------------------- array --------------------------

 const months = ['Jan', 'March', 'April', 'June','July', 'August'];

  -------------------------- const lastElement = months.splice(-1,1,'replaceLastfromOriginal'); --------------------------

  const lastElement = months.splice(-1,1,'replaceLastfromOriginal');
 //lastElement = ['August'];
 //months = ['Jan', 'March', 'April', 'June','July','replaceLastfromOriginal'];

 --------------------------
               </example>
           </paragraph>
       </content>
   </chapter>


   <chapter>
       <subject>Array.prototype.sort()</subject>
       <content>
            <subtitle>Array.prototype.sort()</subtitle>
           <paragraph>
               <info>Array.prototype.sort() 
                By default sorting will only for charackters of the same Case (lower or upper not mixed).
                It will sort ascenting 
                </info>
               <example>
-------------------------- array --------------------------

const charackters = ['chris','aga','STEFAN','greg'];

digits.sort();
//["STEFAN", "aga", "chris", "greg"] not quite what is expected;

THEREFORE YOUR SAVE BET IS TO USER SORT FUNCTIONS as explain in next sections 

----------------------------------------------------
                 
               </example>
      </paragraph>
       <subtitle>Array.prototype.sort(callback) integers</subtitle>
           <paragraph>
               <info>
                sort ascenting;
                Array.prototype.sort( (a,b)=> a-b );
                sort ascenting;
                Array.prototype.sort( (a,b)=> b-a );
               </info>
               <example>
-------------------------- array --------------------------
const arraySortNumbers = [6,5,1,9];


-------------------------- 1 round  --------------------------
    compare(6-5);     // (a>b) returns 1, a is greater than b  (In other words, 5 will come first.) 5,6   [(5,6),1,9]
    compare(6-1);  // (a>b) returns 5, a is greater than b  (In other words, 1 will come first.)  1,6     [5,(1,6),9]
    compare(6-9);  // (a less than b) returns -3, a is less than b  (In other words, 6 will come first.)   6,9      [5,1,(6,9)]
    
-------------------------- 2 round  --------------------------
    compare(5-1);  // returns 4, a is greater than b  (In other words, b will come first.)  1,5     [(1,5),6,9]
    compare(5-9);  // returns -4, a is greater than b  (In other words, b will come first.)  5,9    [1,(5),6,(9)]
    
 --------------------------3 round  --------------------------
    compare(1-9);  // returns -8, a is greater than b  (In other words, b will come first.)  1,9    [(1),5,6,(9)]

      ( IN BRACKETS WE HAVE NUMBERS THAT ARE BEING COMPARED AND WHAT ORDER THEY SORT);


-------------------------- sorting ascenting --------------------------

arraySortNumbers.sort((a,b)=> a-b );

-------------------------- sorting descenting --------------------------

arraySortNumbers.sort((a,b)=> b-a );

--------------------------------------------------------------------------------------------------------

               </example>
           </paragraph>
       <subtitle>Array.prototype.sort(callback) non-integers</subtitle>
           <paragraph>
               <info>when you soring not-numeric values you need manually return either 0,1 or -1 </info>
               <example>
-------------------------- array --------------------------

var mixedCaseAnimals=["ant", "bee", "Cat", "dog", "Elephant"];

-------------------------- ascending order --------------------------

mixedCaseAnimals.sort(function (a, b) {
   var x = a.toUpperCase(),
       y = b.toUpperCase();

   if (x > y) { 
       return 1; //y will be before x;
   }
   if (x &lt; y) { 
       return -1; //x will be before y;
   }

   //default x = y ;
   return 0;
});

-------------------------- descending order --------------------------
mixedCaseAnimals.sort(function (a, b) {
   var x = a.toUpperCase(),
       y = b.toUpperCase();

   if (x > y) { 
       return -1; //x will be before y
   }
   if (x &lt; y) { 
       return 1; //y will be before x 
   }

   //default x = y ;
   return 0;
});

console.log(mixedCaseAnimals); 

----------------------------------------------------
               </example>
           </paragraph>
       <subtitle>Array.prototype.sort() nested Objects (summary)</subtitle>
           <paragraph>
               <info>As shown in other examples based on numeric and non-numeric values sorting will execute below:</info>
               <example>
                 
 -------------------------- array with nested object --------------------------
const employees = [
        {name: 'john', salary: 90000, hireDate: "July 1, 2011"},
        {name: 'david', salary: 75000, hireDate: "August 15, 2011"},
        {name: 'ana', salary: 80000, hireDate: "December 12, 2011"}
];

 -------------------------- SORT by name (non-numeric) --------------------------
//ASC 

employees.sort(function (a, b) {
     var x = a.name.toUpperCase(),
         y = b.name.toUpperCase();

     if (x > y) { 
         return 1; //y will be before x;
     }
     if (x &lt; y) { 
         return -1; //x will be before y;
     }

     //default x = y ;
     return 0;
 });

//DESC
employees.sort(function (a, b) {
     var x = a.name.toUpperCase(),
         y = b.name.toUpperCase();

     if (x > y) { 
         return -1; //x will be before x;
     }
     if (x &lt; y) { 
         return 1; //y will be before x;
     }

     //default x = y ;
     return 0;
 });


 -------------------------- SORT by salary (numeric) --------------------------
 //ASC 

employees.sort((a, b) => a.salary - b.salary);
//DESC 
employees.sort((a, b) => b.salary - a.salary);


--------------------------  SORT by DATE (numeric) Date object converted to Number --------------------------
//ASC

employees.sort((x, y) => {
    var a = new Date(x.hireDate);
        b = new Date(y.hireDate);
    return a - b;
});

//DESC
employees.sort((x, y) => {
    var a = new Date(x.hireDate);
        b = new Date(y.hireDate);
    return b - a;
});
-------------------------- --------------------------
</example>
           </paragraph>
       </content>
   </chapter>
      <chapter>
          <subject>ES5/ES6 array.map(callback)</subject>
          <content>
              <paragraph>
                  <info>
                     array.map(callback) will create a new copy of array as a final result of looping through (it is a great way to modify original content);
                  </info>
                  <example>
-------------------------- array --------------------------

   const orgArray = [4,5,6,7];

-------------------------- array.map() --------------------------

   const newArray = orgArray.map((e,i)=> e+3);

-------------------------- --------------------------

                  </example>
              </paragraph>
          </content>
      </chapter>
      <chapter>
          <subject>ES6 array methods</subject>
          <content>
             <subtitle>array.some(callback)</subtitle>
             <paragraph>
                 <info>array.some(callback):
                   tests whether at least one element in the array passes the test implemented by the provided function.Contrary to every that test if every element pass</info>
                 <example>
-------------------------- array --------------------------

[1, 2, 3, 4, 5].some(even=>even % 2 === 0); //true 

-------------------------- to prove we can find those; --------------------------

[1, 2, 3, 4, 5].find(even=>even % 2 === 0) //2

--------------------------
                 </example>
             </paragraph>
             <subtitle>array.every(callback)</subtitle>
             <paragraph>
                 <info>array.every(callback) will return true or false depending if all element meet condition in callback function. If only one element doesnt then it will return false.</info>
                 <example>
-------------------------- array --------------------------

[1, 2, 3, 4, 5].every(even=>even % 2 === 0); //false contray to some; 

-------------------------- array check if all values are numbers --------------------------

const allNumbers = [4,6,7.7].every((e,i)=> !isNaN(e) ) //returns true;
const mixedValues = [4,6,7.7,'string'].every((e,i)=> !isNaN(e) ) //returns false;

-------------------------- --------------------------
                 </example>
             </paragraph>
              <subtitle>array.find(callback)</subtitle>
              <paragraph>
                  <info>
                     array.find(callback) will stop interation once look for element is find. it will return a value being looked.
                  </info>
                  <example>
-------------------------- array --------------------------

   [4,5,6,7].find((e,i)=> e===6); //return 6

-------------------------- --------------------------

                  </example>
              </paragraph>
               <subtitle>array.findIndex(callback)</subtitle>
              <paragraph>
                  <info>
                     array.findIndex(callback) will stop interation once look for element is find. it will return an index of value being looked.
                  </info>
                  <example>
-------------------------- array --------------------------

   [4,5,6,7].findIndex((e,i)=> e===6); //return 2

-------------------------- --------------------------

                  </example>
              </paragraph>
              <subtitle>array.filter(callback)</subtitle>
              <paragraph>
                  <info>array.filter(callback) will filter array elements according condition in callback function (no loop needed it will do it in one go)</info>
                  <example>
-------------------------- oddNumbersFilter array  --------------------------

    const oddNumbersFilter = [1, 2, 3 ].filter( x => x % 2 !== 0); //1,3 

-------------------------- evenNumbersFilter array  -------------------------- 

    const evenNumbersFilter = [1, 2, 3 ].filter( x => x % 2 === 0); //2 

-------------------------- -------------------------- --------------------------
                  </example>
              </paragraph>
              <subtitle>copyWithin(target, start, end)</subtitle>
              <paragraph>
                  <info>copyWithin(target, start, end)</info>
                  <example>
-------------------------- array  --------------------------
var array1 = [1, 2, 3, 4, 5];

-------------------------- place at position 0 the element between position 3 and 4 -------------

console.log(array1.copyWithin(0, 3, 4)) // expected output: Array [4, 2, 3, 4, 5]

-------------------------- place at position 1 the elements after position 3 --------------------------

console.log(array1.copyWithin(1, 3));  // expected output: Array [4, 4, 5, 4, 5];

------------------------ ------------------------
                  </example>
              </paragraph>
              <subtitle>array.fill(value,[startIndex, endIndex])</subtitle>
              <paragraph>
                  <info>array.fill(value,[startIndex, endIndex])</info>
                  <example>
---------------array.fill(value,[startIndex, endIndex])-------------

[1, 2, 3, 4].fill(0, 2, 4); //[1, 2, 0, 0];

---------------array.fill(value,[startIndex])-------------

[1, 2, 3, 4].fill(5,1); //[1, 5, 5, 5];

---------------array.fill(value)-------------

[1, 2, 3, 4].fill(6); //[6, 6, 6, 6];

--------------- ---------------
                  </example>
              </paragraph>
              <subtitle>array.includes(value)</subtitle>
              <paragraph>
                  <info>array.includes(value) it will check if array already has value (is or is not included)</info>
                  <example>
-------------------------- array  --------------------------

const values = [1,2,3,4,5,6,2,3,5];

-------------------------- make copy of values but skip duplicates  --------------------------
const valuesNoDuplicates = values.reduce((arr,e,i)=>{
     if(!arr.includes(e)){
       arr.push(e);
     }

   return arr;
},[]);

-------------------------- --------------------------
                    
                  </example>
              </paragraph>
          </content>
      </chapter>
      <chapter>
          <subject>array.reduce(callback(a,e,i){return a},startPoint)</subject>
          <content>
              <subtitle>array.reduce(callback) interator couter</subtitle>
              <paragraph>
                  <info>
                     array.reduce(callback) is the way to manipulate elements and it will produce new array. The simplest example is to use as math calculation calculator. needs to return an acumulator (a) in a callback function callback(),0 the extra 0 parameter (or any other value) is a starting point this time it has to be number cause reduce return number value (look for other examples below)
                  </info>
                  <example>
-------------------------- array  --------------------------

const figures = [2,4,5,6];

-------------------------- reduce as calculator with starting point Number 0 or skiped (if we want to start form 0 could be skiped) -------------

const sum = figures.reduce((a,e,i)=>a=a+e,0) //17
const multiply1 = figures.reduce((a,e,i)=>a*=e) //240

--------------------------  --------------------------
         
                  </example>
              </paragraph>
              <subtitle>array.reduce(callback) array calculor with starting point </subtitle>
              <paragraph>
                  <info>array.reduce(callback) array, it will return accumulator as array and expect an array as starting point.</info>
                  <example>
-------------------------- array  --------------------------

const figures = [2,4,5,6];

-------------------------- reduce as calculator with starting point--------------------------


 const justlikeMap = figures.reduce(
 (a,e,i)=>{
   a[i] = e+3;
   return a;
 },[]) //starting point empty array;

  --------------------------  --------------------------  -------------------------- 
                  </example>
              </paragraph>
              <subtitle>array.reduce(callback) Object transformation </subtitle>
              <paragraph>
                  <info>array.reduce(callback) Object, it will return Object , because the starting point is Object.
                    It coule be Empty {} will ruturn new object 
                    or could be exisiting {prop:'prop'} it will merge to it</info>
                  <example>

-------------------------- array.reduce() converted to object as outcome  --------------------------

const figures = [2,4,5,6];
const existingObject = {pointer:'greg'};

 const objectArray = figures.reduce((a,e,i)=>{
   a.values = figures.map((m)=>m+3);
   return a;
 },existingObject) //starting point an existing Object;

 console.log(objectArray);

  --------------------------  --------------------------  -------------------------- 
                  </example>
              </paragraph>
          </content>
      </chapter>
 </chapters>