<html lang="en"><head>
  <meta charset="UTF-8">  
  <title>tutorial === Layout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/tutorial.css">
  <link rel="stylesheet" href="css/tooltip.css">
</head>
<body translate="no">
<div class="l-site">
  <div class="l-nav">
    <nav class="nav">
      <input type="text" placeholder="Search" id="search">
      <div style="clear: both;"></div>
      <!-- nunjucks loop-->
            
<ul class="links">
<!--list-tag-->
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">interface</a><span class="tooltiptext">interface</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>object interface</a><span class="tooltiptext">object interface</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Interface intersections (extends keyword)</a><span class="tooltiptext">Interface intersections (extends keyword)</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">type</a><span class="tooltiptext">type</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>object type</a><span class="tooltiptext">object type</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>type aliases</a><span class="tooltiptext">type aliases</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">interface versus type (diffrences)</a><span class="tooltiptext">interface versus type (diffrences)</span>
                 
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">js libraries with typescript (popular libraries)part 1</a><span class="tooltiptext">js libraries with typescript (popular libraries)part 1</span>
                 
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">js libraries define your own d.ts file (part 2)</a><span class="tooltiptext">js libraries define your own d.ts file (part 2)</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>export/import common.js module in TS</a><span class="tooltiptext">export/import common.js module in TS</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>declare &#39;key word&#39; in d.ts file</a><span class="tooltiptext">declare &#39;key word&#39; in d.ts file</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">javascript types in typescript</a><span class="tooltiptext">javascript types in typescript</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>array</a><span class="tooltiptext">array</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>object</a><span class="tooltiptext">object</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>function</a><span class="tooltiptext">function</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">Promises</a><span class="tooltiptext">Promises</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>regular Promise syntax</a><span class="tooltiptext">regular Promise syntax</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Promise chaining</a><span class="tooltiptext">Promise chaining</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>promise fetch response</a><span class="tooltiptext">promise fetch response</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Promise is async function</a><span class="tooltiptext">Promise is async function</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">typescript own types</a><span class="tooltiptext">typescript own types</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>tuple</a><span class="tooltiptext">tuple</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>types literals</a><span class="tooltiptext">types literals</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>types guards</a><span class="tooltiptext">types guards</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">Utillity types (build-in)</a><span class="tooltiptext">Utillity types (build-in)</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Partial&lt;T&gt;</a><span class="tooltiptext">Partial&lt;T&gt;</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Partial in generics (partial explained)</a><span class="tooltiptext">Partial in generics (partial explained)</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Required&lt;type&gt;</a><span class="tooltiptext">Required&lt;type&gt;</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Readonly&lt;classicMotorbikeCollection&gt;</a><span class="tooltiptext">Readonly&lt;classicMotorbikeCollection&gt;</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Record same as {[key:string]:any}</a><span class="tooltiptext">Record same as {[key:string]:any}</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Record&lt;string, customType&gt;</a><span class="tooltiptext">Record&lt;string, customType&gt;</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Pick&lt;CystomType, &#39;make&#39; | &#39;type&#39;&gt;</a><span class="tooltiptext">Pick&lt;CystomType, &#39;make&#39; | &#39;type&#39;&gt;</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Omit&lt;MotorbikesSet, &#39;make&#39; | &#39;type&#39;&gt;</a><span class="tooltiptext">Omit&lt;MotorbikesSet, &#39;make&#39; | &#39;type&#39;&gt;</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Exlude&lt;T,U&gt;</a><span class="tooltiptext">Exlude&lt;T,U&gt;</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Extract&lt;T,U&gt;</a><span class="tooltiptext">Extract&lt;T,U&gt;</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">Typescript generics</a><span class="tooltiptext">Typescript generics</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Build-in generics</a><span class="tooltiptext">Build-in generics</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>custom multiple generics in function</a><span class="tooltiptext">custom multiple generics in function</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>custom generics in function</a><span class="tooltiptext">custom generics in function</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>types generic with constrains</a><span class="tooltiptext">types generic with constrains</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Interface and type with generics</a><span class="tooltiptext">Interface and type with generics</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Interface and type with generics and generic constrains</a><span class="tooltiptext">Interface and type with generics and generic constrains</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Interface and type with generics and generic constrains (complex)</a><span class="tooltiptext">Interface and type with generics and generic constrains (complex)</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Interface generic with &#39;key of &#39; object keyword</a><span class="tooltiptext">Interface generic with &#39;key of &#39; object keyword</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">functions</a><span class="tooltiptext">functions</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>function overloads syntax</a><span class="tooltiptext">function overloads syntax</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>function Contextual Typing</a><span class="tooltiptext">function Contextual Typing</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>function signature v function interface</a><span class="tooltiptext">function signature v function interface</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">Type casting</a><span class="tooltiptext">Type casting</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Typecasting v type assertions</a><span class="tooltiptext">Typecasting v type assertions</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>double casting (last force method)</a><span class="tooltiptext">double casting (last force method)</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Type casting with html elements</a><span class="tooltiptext">Type casting with html elements</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>type casting not null values</a><span class="tooltiptext">type casting not null values</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts">React with typescipt</a><span class="tooltiptext">React with typescipt</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Functional component</a><span class="tooltiptext">Functional component</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>Functional component with hook useState()</a><span class="tooltiptext">Functional component with hook useState()</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>FC with Mouse Event</a><span class="tooltiptext">FC with Mouse Event</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useCallback()</a><span class="tooltiptext">useCallback()</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useCallback() with React.Memo(ChildCompoent)</a><span class="tooltiptext">useCallback() with React.Memo(ChildCompoent)</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useMemo()</a><span class="tooltiptext">useMemo()</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useEffect() async</a><span class="tooltiptext">useEffect() async</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useEffect() object in depedency</a><span class="tooltiptext">useEffect() object in depedency</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useEffect() clean up function</a><span class="tooltiptext">useEffect() clean up function</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useRef()</a><span class="tooltiptext">useRef()</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>useRef() counter versus useState counter</a><span class="tooltiptext">useRef() counter versus useState counter</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>FC with Mouse Event</a><span class="tooltiptext">FC with Mouse Event</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/typescript_tuts" partition>FC with Mouse Keyboard Event</a><span class="tooltiptext">FC with Mouse Keyboard Event</span>
                        
                    </ul>
                
      </li>
    
<!--end-list-tag-->
</ul>

       <!-- nunjucks loop-->
    </nav>
  </div>
  <div class="l-page">
    <div class="menu">
      <div class="menu-hamburger"></div>
    </div>
      <!-- nunjucks loop-->
          
<div class="sectionWrapper">
  <div class="sectionContainer">
   
      
      <section  class="band band-b activeSection"  class="band band-b">
          <h1> interface </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>interface can only represent object structure to a object structure data. The interface should be perceded by capital I letter and name start with capital as well, it is industry standard.</p>
                  <div class="codeWraper">
                    <code>------- regular interface ------------

interface IObjectStructure {
  name: string;
  lastname: string;
  age: number;
}

//all properties from interface has to be place in const object declaraion
const person: objectStructure = { name: &#39;greg&#39;, lastname: &#39;gil&#39;, age: 38 };

------- [key]:value type interface ------------

interface IAnyKeyUnknownValue {
  [key:string]: unknown;
}

//this objet interface will take as many props as possible of type string and value of anything
const person1: IAnyKeyUnknownValue = { name: &#39;greg&#39;, lastname: {greg:&#39;greg&#39;}, age: 38, arr:[{}] };


-----------------------------------------------------------------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>Interfaces can be combined as I1 and I2 as well as I1 or I2</p>
                  <div class="codeWraper">
                    <code>//---- 1a. Interface  combined naturally by intface duplication (not reccomended though)

interface Dude {
  name: string;
  age: number;
}

interface Dude {
  job: string;
  position: string;
}

let myEmployee10: Dude;
myEmployee10 = {
  name: &#39;Darek&#39;,
  age: 31,
  job: &#39;contract&#39;,
  position: &#39;developer&#39;,
};

//---- 1b. Interface can be extended as well (recommended) with the same effect

interface Dude1 {
  name: string;
  age: number;
}

interface Dude2 extends Dude1 {
  job: string;
  position: string;
}

let myEmployee11 = {} as Dude2;
myEmployee11 = {
  name: &#39;Darek&#39;,
  age: 31,
  job: &#39;contract&#39;,
  position: &#39;developer&#39;,
};

//---- 2. Interface one of another with or | operator


interface Dude100 {
  name: string;
  age: number;
}

interface Dude200 {
  job: string;
  position: string;
}

let myEmployee14: Dude100 | Dude200;

myEmployee14 = {
  name: &#39;string&#39;,
  job: &#39;contract&#39;,
  position: &#39;developer&#39;,
}; 
// a bit buggy cause it accepts 3 arguments it should accpet 2 or 4

------------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> type </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>type can represent object structure or any other data include type literals</p>
                  <div class="codeWraper">
                    <code>------- regular interface ------------

type ObjectStructure = {
  name: string;
  lastname: string;
  age: number;
}

//all properties from interface has to be place in const object declaraion
const person: objectStructure = { name: &#39;greg&#39;, lastname: &#39;gil&#39;, age: 38 };

------- [key]:value type interface ------------

type IAnyKeyUnknownValue = {
  [key:string]: unknown;
}

//this objet interface will take as many props as possible of type string and value of anything
const person1: IAnyKeyUnknownValue = { name: &#39;greg&#39;, lastname: {greg:&#39;greg&#39;}, age: 38, arr:[{}] };

------- type literal ------------

type = availableColors = &#39;blue&#39; | &#39;green&#39;


-----------------------------------------------------------------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>Types can be combined as I1 and I2 as well as I1 or I2</p>
                  <div class="codeWraper">
                    <code>//---- 1a. Interface  combined with &amp; and operator

type Dude = {
  name: string;
  age: number;
}

type Dude2 = {
  job: string;
  position: string;
}

let myEmployee10: Dude &amp; Dude2;
myEmployee10 = {
  name: &#39;Darek&#39;,
  age: 31,
  job: &#39;contract&#39;,
  position: &#39;developer&#39;,
};



//---- 2. type one of another with or | operator


type Dude100 = {
  name: string;
  age: number;
}

type Dude200 = {
  job: string;
  position: string;
}

let myEmployee14: Dude100 | Dude200;

myEmployee14 = {
  name: &#39;string&#39;,
  job: &#39;contract&#39;,
  position: &#39;developer&#39;,
}; 
// a bit buggy cause it accepts 3 arguments it should accpet 2 or 4

------------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> interface versus type (diffrences) </h1> 
          

            
              <div class="band-container">
                <div class="band-inner">

                  <p>They are preety much the same. The only diffrence the type allows you to specify type literal as 
                type greg = &#39;greg&#39; . Interfaces are limited to object type structure. Also Disjoint unions alowed only in types</p>
                  <div class="codeWraper">
                    <code>---------- type literals ---------------

type GregorDaniel = &#39;Greg&#39; | &#39;Daniel&#39;;

const myEmployee1: GregorDaniel = &#39;Greg&#39;;
const myEmployee2: GregorDaniel = &#39;Daniel&#39;;
const myEmployee3: GregorDaniel = &#39;Michal&#39;; //opps he is not specified in type

//or tuples declarion can not be done by interface
type Reponse = [string, number];
const x: Reponse = [&#39;value&#39;, 5];

//Disjoint unions only in types
type DomesticAnimals = { type: &#39;Dog&#39; } | { type: &#39;Cat&#39; };


-----------------------------------------</code>
                  </div>
                </div>
              </div>
            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> js libraries with typescript (popular libraries)part 1 </h1> 
          

            
              <div class="band-container">
                <div class="band-inner">

                  <p>if you using popular library, most likely a community has alredy 
                difined js library to work with types , all that needs to be done</p>
                  <div class="codeWraper">
                    <code>--------------

//-------how to finde types declaration for a js library---------       

1. google react types or react @types 

2. search for types packages at https://www.typescriptlang.org/

3. If you can not find it then you will need to make it your own (next chapter)

-------------</code>
                  </div>
                </div>
              </div>
            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> js libraries define your own d.ts file (part 2) </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>the bare minimum to make TS bitching about lack od declaration file is to set  

&quot;allowJs&quot;: false, 

The rules are simple for imports in TS: 

    import lib from &#39;./lib&#39;

1 First typescript will attepmt to look for file lib.ts or lib.tsx

2   if can no find it then it will look for .js file (if  &quot;allowJs&quot;: true,) in tsconfig

3   if TS has option  &quot;allowJs&quot;: false and lib has .js extension then will look for its type definition in d.ts file 

How you construct d.ts file depends of TS version. Always reffer to latest TS documentation and update your TS if possible. 

https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html</p>
                  <div class="codeWraper">
                    <code>--------------

//-------those are the examples for TS typescript@4.1.2 ---------       

1  -------- common way to named export in common.js ------ 

const maxInterval = 12;

function getArrayLength(arr) {
  return arr.length;
}

module.exports = {
  getArrayLength,
  maxInterval,
};


2  --------  declaration file for above ------ 

export function getArrayLength(arr: any[]): number;
export const maxInterval: 12;

3 --- usage of the typescript 

//keep common.js format 
const moduleWithFunction = require(&#39;.file_path&#39;);

moduleWithFunction.getArrayLength([2])
moduleWithFunction.maxInterval

//or ES6 format 
import { maxInterval, getArrayLength } from &#39;.file_path&#39;;

getArrayLength([2])
maxInterval



-------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>There are certain rule what is allowed  in d.ts file. For example if you export funtion you allow to only export function defintion (function name =&gt; parameter it takes =&gt; return value) but you are not allowd to crate funcion body here. To define const or module you need to use &#39;key word&#39; declare.

                the full guidance can be found here:

                https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html</p>
                  <div class="codeWraper">
                    <code>--------------

/******** simple example of constant declarion from docs ***************/

/*
     this simply exports a number in common js as default export
*/


/************  Example 1 *************/

module.exports = 3.142;

******* usage in typescipt *****/

//keep common js:
const pi = require(&#39;.path_file&#39;)
console.log(&#39;pi equals:&#39;, pi)

//or ES6 module 
import pi from &#39;.path_file&#39;
console.log(&#39;pi equals:&#39;, pi) 

/*******  declaration file for above file.d.ts file  *****/

declare const pi: number;
export default pi;

/**Explanation*/

start with declaring a const &#39;pi&#39; of type:number and export const as default 


/************  Example 2 *************/

module.exports = /hello( world)?/;

******* usage in typescipt *****/

//keep common js:
const helloWorldReg = require(&#39;.path_file&#39;)

console.log(helloWorldReg.test(&#39;hello&#39;)) //prints true

//or ES6 module 
import helloWorldReg from &#39;.path_file&#39;

console.log(helloWorldReg.test(&#39;greg&#39;)) //prints false


/*******  declaration file for above file.d.ts file  *****/

declare const helloWorld: RegExp;
export default helloWorld;

/**Explanation*/

start with declaring a const &#39;helloWorld&#39; of type:RegExp and export cosnt as default 


-------------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> javascript types in typescript </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>array typescript declaration</p>
                  <div class="codeWraper">
                    <code>--------------

//one way         
const array: string[] = [&#39;greg&#39;];

//same thing another way
const array2: Array&lt;string&gt; = [&#39;greg&#39;];

//with onion types
const customers: Array&lt;string | number&gt; = [2];

-------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>object typescript declaration</p>
                  <div class="codeWraper">
                    <code>--------------

//inline declaration

const anyKeyObject: { [key: string]: string } = {
  greg: &#39;is cool&#39;,
  age: &#39;unknown&#39;,
};


//Object type assertion

const anyKeyObject2 = {
  greg: &#39;is cool&#39;,
  age: &#39;unknown&#39;,
  gre: &#39;2&#39;,
} as { [key: string]: string };


//3a Object dusctructring

const scientist: { firstName: string, experience: number } = { firstName: &#39;Robert&#39;, experience: 9000 };
const { firstName, experience } = scientist;


-------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>function arguments</p>
                  <div class="codeWraper">
                    <code>-------------        

//4. functions args
//optional
---- const seter = (arg: string, arg2?: number | string) =&gt; {};
seter(&#39;first&#39;);

//optional and default
---- const seter2 = (arg: string, arg2 = 2) =&gt; {};
seter2(&#39;first&#39;);

//optional and default destructring object properties
---- const seter3 = ({ arg=1, arg2 = 3 }) =&gt; {};

//both the same
---- const seter3a = ({ arg, arg2 } = { arg: 1, arg2: 3 }) =&gt; {};
seter3a();

//combination of obobe
---- const seter4 = ({ arg, arg2 = 2 } = { arg: 4 }) =&gt; {};
seter4();


-------------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> Promises </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>Typescript by defualt will alwaus return promise as 


Promise&lt;unknown&gt;

or for fetch 

Promise&lt;Response&gt;

It is alwasy better to be more presicised what Promise should 
return as the examples below:</p>
                  <div class="codeWraper">
                    <code>//default Promise return: unknown (even though we contextually provide string)

new Promise((resolve) =&gt; {resolve(&#39;1&#39;)});


//promise explicitly returns: string 

new Promise&lt;string&gt;((resolve) =&gt; {resolve(&#39;1&#39;)});

 //promise explicitly returns: object of any properties 

new Promise&lt;Record&lt;string,any&gt;&gt;((resolve) =&gt; {resolve({prop:1,prop2:&#39;string&#39;})});</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>Promise that returns another promise will alwasy return a promise type that is last in the chain:</p>
                  <div class="codeWraper">
                    <code>//first promise returns string;

const firstPromise = new Promise&lt;string&gt;((resolve) =&gt; {resolve(&#39;1&#39;)});   

//second promise is to be chained to the first 

const secondPromise = firstPromise.then((firstRusult)=[firstResult])

//third Promise will be of type of last one 

const thirdPromise:string[] = firstPromise.then((secondPromise)=secondPromise)</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>fetch response is also promise and has the same rules as promise chaining the last promise return in fetch or fetch itselft (if there is only
              fetch on chaining) will have Return value of Promise&lt;Response&gt; if you want to convert &lt;Response&gt; to the rigid value as string then first you need to converted to unknown</p>
                  <div class="codeWraper">
                    <code>//converting default Promise&lt;Response&gt; =&gt; Promise&lt;unknown&gt; =&gt; Promise&lt;string&gt;

const one:Promise&lt;Response&gt; = fetch(&#39;url&#39;) 
const three:Promise&lt;unknown&gt;  = one.then((result)=&gt; result as unknown)
const four:Promise&lt;string&gt;  = three.then((result)=&gt; result as string)

console.log(four.then((result)=&gt;result ))

//the sequence has to be as the one above for TS to be happy about conversion</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-4">
                <div class="band-inner">

                  <p>In example when promise is assign to the async funcion as return type then we can cast the type for the Response since the Promise response by defualt will be &lt;Promise&lt;unknown&gt;&gt;</p>
                  <div class="codeWraper">
                    <code>//function has been casted from Promise&lt;unknown&gt; to Promise&lt;string&gt; 

async function asyncCode() {
  return new Promise(resolve=&gt;resolve(&#39;ready&#39;))
}

const ss:Promise&lt;string&gt; = asyncCode() as Promise&lt;string&gt;
console.log(ss.then(()=&gt;&#39;greg&#39;))</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> typescript own types </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>tuple allows you to specify ordered array, similar to destrucring array</p>
                  <div class="codeWraper">
                    <code>------- ordered array tuple ------------

const arr:[string,number] = [&#39;3&#39;, 4]

//this array only takes max 2 arguments of a type string[0] and number[1]</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>types literals allows you to specify literal value as :

                type animal = &#39;dog&#39; | &#39;cat&#39;</p>
                  <div class="codeWraper">
                    <code>-------- literal type allowance --------

const myAnimal = &#39;dog&#39; //correct
const myAnimal2 = &#39;hamster&#39; //ups you only have option for &quot;dog&quot; | &quot;cat&quot;

------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>Types guards allow to check for specific type either by  &#39;property&#39; in object method that loops
                through types or swich method.</p>
                  <div class="codeWraper">
                    <code>-------- (&#39;property&#39; in object) type guards ---------

function moveAnimal(animal: Animal) {
  //1. One options is to use loop &#39;property&#39; in object
  if (&#39;flyingSpeed&#39; in animal) {
    console.log(&#39;Animal is moving with&#39;, animal.flyingSpeed);
  }

  if (&#39;runnigSpeed&#39; in animal) {
    console.log(&#39;Animal is moving with&#39;, animal.runnigSpeed);
  }
}

-------- switch statement with  type guards ---------

//discriminated unions with switch statement (access some common property as comparison)

function moveAnimalDiscriminatedTypes(animal: Animal) {
  switch (animal.kind) {
    case &#39;bird&#39;:
      console.log(&#39;Animal is moving with&#39;, animal.flyingSpeed);
      break;
    case &#39;horse&#39;:
      console.log(&#39;Animal is moving with&#39;, animal.runnigSpeed);
      break;
    default:
      break;
  }
}</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> Utillity types (build-in) </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>Partial will take one generic type and make it all properties
 * from required to optional, that means we can call even with empty object
 * but not with new property that dont exist in original type.</p>
                  <div class="codeWraper">
                    <code>---------------- Partial of a type -------------

interface motorbike {
  color: string;
  engineSize: number;
}
let kawasaki: motorbike = {
  color: &#39;green&#39;,
  engineSize: 1200,
};

//Partial will make all properties optional 

let kawasakiSport: Partial&lt;motorbike&gt; = {
  engineSize: 1000,
};
let kawasakiCruizer: Partial&lt;motorbike&gt; = {
  color: &#39;black&#39;,
};

//empty object is aslo allowe cause it all properties or partial but also none
let kawasakiMotorUnknow: Partial&lt;motorbike&gt; = {};


//error newModel dont exist in original motorbike interface
let kawasakiMotorNewModel: Partial&lt;motorbike&gt; = { newModel: &#39;not allowed&#39; };

----------------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>Partial can be also written with generics</p>
                  <div class="codeWraper">
                    <code>-------- Partial can be break out as generic --------------

type PartialManually&lt;Obj&gt; = {
  [Prop in keyof Obj]?: Obj[Prop];
};

let kawasakiSport1: PartialManually&lt;motorbike&gt; = {
  engineSize: 1000,
};

let kawasakiCruizer1: PartialManually&lt;motorbike&gt; = {
  color: &#39;black&#39;,
};

//empty object is aslo allowe cause it all properties or partial but also none

let kawasakiMotorUnknow1: PartialManually&lt;motorbike&gt; = {};

//but new properties are not allowed 

let kawasakiMotorNewModel1: PartialManually&lt;motorbike&gt; = {
  newModel: &#39;not allowed&#39;,
};

--------------------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>Opposite to Partial will take one generic type and make it all properties
 * from optional to required</p>
                  <div class="codeWraper">
                    <code>------- all properties are required in the object structure ----------
                
interface classicMotorbike {
  color?: string;
  engineSize?: number;
  old: Boolean;
}
let BSA: classicMotorbike = {
  old: true,
};
//now convert all properties to mandatory;
let Triumph: Required&lt;classicMotorbike&gt; = {
  color: &#39;blue&#39;,
  engineSize: 865,
  old: false,
};

----------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-4">
                <div class="band-inner">

                  <p>Makes all propeties readonly so they can not be changed</p>
                  <div class="codeWraper">
                    <code>------- all properties are required and they can not be chanded (read-only) in the object structure ----------

interface classicMotorbikeCollection {
  color: string;
  engineSize: number;
  old: Boolean;
}

//now convert all properties to mandatory;
let Vincent: Readonly&lt;classicMotorbikeCollection&gt; = {
  color: &#39;blue&#39;,
  engineSize: 865,
  old: false,
};

----------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-5">
                <div class="band-inner">

                  <p>Record has to define 2 types for the object</p>
                  <div class="codeWraper">
                    <code>==&gt; Record as any object
 Record&lt;any,any&gt;

==&gt; Record as string property any any value

 Record&lt;string,any&gt; ===  {[key:string]:any}

==&gt; Record as string proprerty with number values

 Record&lt;string,number&gt; ===  {[key:string]:number}

 ==&gt; Record with specific properties and string values

 Record&lt;&#39;prop1&#39;|&#39;prop2&#39;,string&gt; ===  {prop1:string,prop2:string}

 ==&gt; Record with specific properties and specific values typescript

Record&lt;&#39;gg&#39;|&#39;pp&#39;,string | number&gt;  === {
      gg:string|number,
      pp:string|number
    }

==&gt; object literals with object literals array

Record&lt;string,Record&lt;string,string | number&gt;[]&gt;
  === {
    [key:string]:{[key:string]:string|number}[]
  }

 ==&gt; Record as string property with number values

 Record&lt;string,Record&lt;any,any&gt;[]&gt; ===  {[key:string]: {[key:string]:any}[]}</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-6">
                <div class="band-inner">

                  <p>Record takes 2 generic types one for object Property, the other for type what property
                They are mainly used for:
                * represent as Array, Object, string etc ...
                * Record are used for objects literals mainly</p>
                  <div class="codeWraper">
                    <code>----------- Record for object -----------------
                

interface Motorbikes {
  make: string;
  type: string;
}

const shoppingList: Record&lt;string, Motorbikes&gt; = {
  owner1: {
    make: &#39;Honda&#39;,
    type: &#39;sport&#39;,
  },
  owner2: {
    make: &#39;Yamaha&#39;,
    type: &#39;sport&#39;,
  },
};
----------- record as array of objects--------------

type  Motorbikestype  = {
  make: string;
  type: string;
}

const shoppingListArray: Record&lt;number, Motorbikestype&gt; = {
  0: {
    make: &#39;Honda&#39;,
    type: &#39;sport&#39;,
  },
  1: {
    make: &#39;Yamaha&#39;,
    type: &#39;sport&#39;,
  },
};

----------- ----------- -----------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-7">
                <div class="band-inner">

                  <p>Pick will take only properties picked, selected from the type, which listed after coma Pick&lt;CystomType, &#39;make&#39; | &#39;type&#39;&gt;</p>
                  <div class="codeWraper">
                    <code>------

interface MotorbikesSet {
  make: string;
  speed: number;
  type: string;
}
//pick only make and type in this case pipe is not or ;)
let newBike: Pick&lt;MotorbikesSet, &#39;make&#39; | &#39;type&#39;&gt; = {
  make: &#39;Triumph&#39;,
  type: &#39;classic&#39;,
};


-----------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-8">
                <div class="band-inner">

                  <p>Omit is the opposite to Pick so omit some properties, whatever is not listed will be taken</p>
                  <div class="codeWraper">
                    <code>------

interface MotorbikesSet {
  make: string;
  speed: number;
  type: string;
}
//pick only make and type in this case pipe is not or ;)
let newBike: Pick&lt;MotorbikesSet, &#39;make&#39; | &#39;type&#39;&gt; = {
  make: &#39;Triumph&#39;,
  type: &#39;classic&#39;,
};


//omit make and type (so pick only speed what is left )
let newBike2: Omit&lt;MotorbikesSet, &#39;make&#39; | &#39;type&#39;&gt; = { speed: 70 };

-----------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-9">
                <div class="band-inner">

                  <p>Exlude allows you to exclude specific values from type literals (eliminate some specific values</p>
                  <div class="codeWraper">
                    <code>.**************  Exlude&lt;T,U&gt; with union types*****************/

//those nubers are types on its own they not just const value:number = 2332

type RegistrationNumbers = 2332 | 34343 | 53453 | 53535353;
type updatedRegistrationNumbers = Exclude&lt;RegistrationNumbers, 34343&gt;;


const RegistrationNumbersSet: updatedRegistrationNumbers = 34343 //error
const RegistrationNumbersSet1:updatedRegistrationNumbers = 53535353 //OK

---------------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-10">
                <div class="band-inner">

                  <p>Extract is the oposite to exlude so it will only take extracted values as final value</p>
                  <div class="codeWraper">
                    <code>.**************  Extract&lt;T,U&gt; with union types*****************/

//those nubers are types on its own they not just const value:number = 2332

type RegistrationNumbers = 2332 | 34343 | 53453 | 53535353;
type updatedRegistrationNumbers = Extract&lt;RegistrationNumbers, 34343&gt;;

const RegistrationNumbersSEt: updatedRegistrationNumbers = 34343 //OK
const RegistrationNumbersSEt1:updatedRegistrationNumbers = 53535353 //error

---------------------------------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> Typescript generics </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>Typescript uses generics for data assumptions, for example

                  const array = []

                  when U hover on array in IDE U will see : array:any[] or never[]</p>
                  <div class="codeWraper">
                    <code>--------------------other exaples of build-in generics------------------------


1) promises always assume generics return type

const promise = new Promise((resolve, reject)=&gt;{
  resolve(&#39;this is done&#39;)
})  

=&gt; this will resolve to Promise:promise&lt;unknown&gt; 
=&gt; but we allowed and should tell typescript what to return as Promise:promise&lt;string&gt;



 ------------------ ------------------ ------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>U can assign generic type to every argument passed to the functtion. To create array from 2 arguments 
                you can return array of tuple as example below</p>
                  <div class="codeWraper">
                    <code>//-------- multiple types generics

function createArray2MultipleTypes&lt;T, U&gt;(n: T, u: U): [T, U] {
  return [n, u];
}

createArray2MultipleTypes&lt;number, number&gt;(6, 4);
createArray2MultipleTypes&lt;string, number[]&gt;(&#39;2&#39;, [4]);
createArray2MultipleTypes&lt;number, number[]&gt;(2, [4]);</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>Generics are used for specific type on single run time. That means , the same function can 
                 be called one with a string and with a number on other time. It is important to make sure that typescript
                 knows what type is currently used, which is called type lock.</p>
                  <div class="codeWraper">
                    <code>-----

function createArray&lt;T&gt;(...arg: T[]) {
  return [...arg];
}

createArray(&#39;one&#39;, &#39;two&#39;, &#39;three&#39;); //string[]
createArray(3, 1, 4); //number[]
createArray([3], [2], [4]); //number[][]

---NOTICE----
//bellow should create an error
createArray({ ss: 3 }, { ee: 3 }, [6]); 

---THEREFORE----
//sometimes you need to help typescript to lock values types you want to use as below

//with type locking
createArray&lt;{ [key: string]: number }&gt;({ ss: 3 }, { ee: 3 }); //array{[key: string]: number }</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-4">
                <div class="band-inner">

                  <p>Generics allows you to pass any type to the function, but sometime U want to be more specific 
                and tell typescirpt that you want to use only sting | numbers, basically contrains what type can be 
                used with your generic function. Generic constrains is the way to tell typescript that you only want to work with certain types.</p>
                  <div class="codeWraper">
                    <code>--------------

type stringOrNumber = string | number;
function createArray1&lt;T extends stringOrNumber&gt;(...arg: T[]) {
  return [...arg];
}

createArray1(2, 4, 5);
createArray1(&#39;2&#39;, &#39;4&#39;, &#39;5&#39;);
createArray1([2], [4], [5]); //not accepted</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-5">
                <div class="band-inner">

                  <p>generics gives multiple types options in intrface of types. U can specify diffrent type on declaration.</p>
                  <div class="codeWraper">
                    <code>---------- interface with generic types ----------------
                
interface KeyPair&lt;T, U&gt; {
  key: T;
  value: U;
}


//----generics gives multiple types options
const kv1: KeyPair&lt;number, string&gt; = { key: 1, value: &#39;Steve&#39; }; // OK
const kv2: KeyPair&lt;string, string&gt; = { key: &#39;set&#39;, value: &#39;Steve&#39; }; // OK
const kv3: KeyPair&lt;{[key:string]:string}, number&gt; = { key: {&#39;prop&#39;:&#39;value&#39;}, value: 55 }; // OK

---------- type with generic types ----------------

type KeyPair1&lt;T, U&gt; = {
  key: T;
  value: U;
}

let kv1type: KeyPair1&lt;number, string&gt; = { key:1, value:&quot;Steve&quot; }; // OK


---------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-6">
                <div class="band-inner">

                  <p>generics gives multiple types options in intrface of types. U can specify diffrent type on declaration. But 
                you can go further and constrain what specific type generic can take. It most cases is a overkill.</p>
                  <div class="codeWraper">
                    <code>---------- interface with generic types and generic constrain ----------------
                
interface someI&lt;T , U extends string| number&gt; {
  job: T;
  value: U;
}

const obj1: someI&lt;string, number&gt; = { job: &#39;greg&#39;, value: 45 };
const obj10: someI&lt;number, number&gt; = { job: 66, value: 45 };
const obj101: someI&lt;number, boolean&gt; = { job: 66, value: true }; //error boolean is not in constrained values 

---------- tyoe with generic types and generic constrain ----------------

type  someI&lt;T , U extends string| number&gt; = {
  job: T;
  value: U;
}

const obj1: someI&lt;string, number&gt; = { job: &#39;greg&#39;, value: 45 };
const obj10: someI&lt;number, number&gt; = { job: 66, value: 45 };
const obj101: someI&lt;number, boolean&gt; = { job: 66, value: true }; //error boolean is not in constrained values 


---------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-7">
                <div class="band-inner">

                  <p>U can go really creative with generics. As the example below.</p>
                  <div class="codeWraper">
                    <code>//this interface accpets:  key of type string , generic to be specified with call

interface KeyP&lt;G&gt; {
  [key: string]: G;
}

//this inteface accets: Generic &lt;T&gt; that is constain to be of shape of KeyP
//KeyP is also generic so it needs to specify what types it works with therefore  KeyP&lt;string | number&gt;

interface KeyPairExtended&lt;T extends KeyP&lt;string | number&gt;, U&gt; {
  job: T;
  value: U;
}

//call generic that needs generic types config: KeyP&lt;string&gt; and string

let gg: KeyPairExtended&lt;KeyP&lt;string&gt;, string&gt; = {
  job: { someProp: &#39;set&#39; },
  value: &#39;Steve&#39;,
}; // OK

//call generic that needs generic types config: KeyP&lt;number&gt; and string

let gg1: KeyPairExtended&lt;KeyP&lt;number&gt;, string&gt; = {
  job: { set: 66 },
  value: &#39;Steve&#39;,
}; // OK

//call generic that needs generic types config: KeyP&lt;number&gt; and string

let ggset: KeyPairExtended&lt;KeyP&lt;number&gt;, string&gt; = {
  job: { someother: 66 },
  value: &#39;Steve&#39;,
}; // OK</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-8">
                <div class="band-inner">

                  <p>Typescript introduces type guard of object &#39;key of&#39; that allows specify what keys must have in the object structure with generics</p>
                  <div class="codeWraper">
                    <code>---------- object structure with generics and &#39;key of&#39; keyword -----------

interface EmployeeInterface {
  position: string;
  startDate: Date;
}
const getObjectPropertyValue = &lt;T extends object, U extends keyof T&gt;(
  obj: T,
  key: U
): string =&gt; {
  return &#39;the value is&#39; + obj[key];
};

getObjectPropertyValue({}, &#39;name&#39;); //error
getObjectPropertyValue({ name: &#39;Greg&#39; }, &#39;name&#39;); //correct


----------------------------------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> functions </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>Function overloads are great example of locking types. For complex function that returns compulation 
                You should use fuction overloads for simple compulation (not depending on types return) you should use types generics with functions</p>
                  <div class="codeWraper">
                    <code>//proper usege of overload functions

function passStringOrNumber(n: string): string;
function passStringOrNumber(n: number): string;
function passStringOrNumber(n: string | number):string {
  if (n === &#39;string&#39;) {
    return &#39;you passed string&#39; + n;
  }
  if (n === &#39;number&#39;) {
    return &#39;you passed number&#39; + n;
  }

  return &#39;&#39;
}

//concluesion function overload is not that diffrent from regular function only allows you to 
//specify exact type arguments eventually combining into union types (which btw is always last in function overload)

passStringOrNumber(4);
passStringOrNumber(&#39;4&#39;);
passStringOrNumber({4}); //not included in function overload</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>Typescript will assume return type, argument from the values 
                predifined before</p>
                  <div class="codeWraper">
                    <code>1. function arguments with function signature 

-----------------------------------
==&gt; second argument Contextually assumed from the function signature

const addConst_ts_es6_cont: (xtype: number, ytypo: number) =&gt; number = (
  x,
  y: number
) =&gt; {
  return x + y;
};

-----------------------------------
==&gt; both arguments types due to contextual function signature

const addConst_ts_es6_cont: (xtype: number, ytypo: number) =&gt; number = (x,y) =&gt; {
  return x + y;
};


2. function arguments with interface

-----------------------------------
==&gt; single argument Contextually assumed from the function interface


interface fn { (xtype: number, ytypo: number):number }

const addConst_ts_es6_cont:fn  = (x:number,y) =&gt; {
  return x + y;
};

-----------------------------------------------------------------
==&gt; both arguments Contextually assumed from the function interface


interface fn { (xtype: number, ytypo: number):number }

const addConst_ts_es6_cont:fn  = (x,y) =&gt; {
  return x + y;
};</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>There are 2 ways of defining your function type either by
        function signature or function interface as below:</p>
                  <div class="codeWraper">
                    <code>---- 1.function interface ----------

interface fn { (xtype: number, ytypo: number):number }

const addConst_ts_es6_cont:fn  = (x:number,y) =&gt; {
  return x + y;
};

----- 2. function type  ----------

type functionType= (x: number, y: number) =&gt; number;

const addConst_ts_es6:functionType = (
  x: number,
  y: number
) =&gt; {
  return x + y;
};


------- 2a function type inline definition ------------

const addConst_ts: (x: number, y: number) =&gt; number = function (
  x: number,
  y: number
) {
  return x + y;
};</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> Type casting </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>Sometimes TS assumes type by its contextual typing but we can cast a type 
                to the Variable, function as below:</p>
                  <div class="codeWraper">
                    <code>--------
1 Typecasting helps you to convert types and provide consistent (expected) results

this.createMarkerStyle(&lt;MarkerSymbolInfo&gt;symbolInfo);
this.createMarkerStyle(symbolInfo as MarkerSymbolInfo);

let element = event as HTMLElement
let element = &lt;HTMLElement&gt;event

// you can start to cast to any
let element = event as any
let element = &lt;any&gt;event


2. Type assertions is actully change type to a diffrent TYPE as below

 let length: number = (&lt;string&gt;lengthField);
 let length: number = (lengthField as string);

2a Cast type for let 

  let whatNum: any = 42;
  let reallyNum = &lt;number&gt;whatNum;
  let reallyNum2 = whatNum as number; (JSX syntax)
  console.log(typeof reallyNum); // number
  console.log(typeof reallyNum2); // number

3 type casting as type of Type 

var x = 5;  
var y = typeof x;</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>you can also double cast type. If you still want that Type, you can use a double assertion, but first asserting to unknown (or any) which is compatible with all types and therefore the compiler no longer complains</p>
                  <div class="codeWraper">
                    <code>//double assertion for Event
                
                function handler(event: Event) {
                    let element = event as unknown as HTMLElement; // Okay!
                }</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>Type casting is the way to tell typescript that the type needed to be used U will provide better, typescript type assumption it not takken.</p>
                  <div class="codeWraper">
                    <code>---------------- jsx single Line--------------

//by default typescirpt takes input as HTMLElement and doesnt allow to access input.value property we know it exists

const inputElement = document.getElementById(&#39;ss&#39;); 
inputElement.value //produces error cause it doesnt exist on HTMLElement

1. one way is to set type before document

const inputElement = &lt;HTMLInputElement&gt;document.getElementById(&#39;ss&#39;);


2. or for the JSX or TSX files use &#39;as&#39; operator

const inputElement = document.getElementById(&#39;ss&#39;) as HTMLInputElement;


------------------------------------------------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-4">
                <div class="band-inner">

                  <p>typescript has a syntax of 

                element.current!.value 

                where element.current! assures that 
                element that current can not be never null or undefined</p>
                  <div class="codeWraper">
                    <code>---------------- not null value for HTML element--------------

const DomElement = document.getElementByID(&#39;id&#39;)!

//the above way we ensure that DomElement is never undefined or null
------------------------------------------------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> React with typescipt </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>Declaration of functional component in Typescript with props Interface</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const functionalCompWithInterface:React.FC&lt;FCInterfaceProps&gt; = (props:FCInterfaceProps) =&gt; {
  return(
    &lt;p&gt;{`${props.name} ${props.age}`}&lt;/p&gt;
  )
}
---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>Declaration of functional component in Typescript with useState hook</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const functionalCompWithInterface:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

    //by specifing initial useState(0) value you setting a type
    const [counter, setCounter] = useState(0);

    //behind the scene creates this:  const [counter, setCounter] = useState&lt;number&gt;(0);

  return(
    &lt;p&gt;{`${name} ${age}`}&lt;/p&gt;
  )
}


---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>Declaration of FC in Typescript with MouseEvent</p>
                  <div class="codeWraper">
                    <code>------------------------------

const functionalCompWithInterface: React.FC= () =&gt; {

//(e:React.MouseEvent) this would be sufficient but better to be more specific

   (e:React.MouseEvent&lt;HTMLButtonElement&gt;)

  const setMe = (e:React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt;{
    setCounter(counter+1)
  }
  return (
    &lt;&gt;
      &lt;button onClick={setMe} &gt;onClick&lt;/button&gt;
   &lt;/&gt;
  );
};


---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-4">
                <div class="band-inner">

                  <p>useCallback allows you to &#39;lock&#39; function based on property 
  into [dependencyArray] or called and lock only once with empty array[]. This funciton will be only re-render 
  if the property that is depending on will change. Remember!, here we are LOCKING THE FUNCTION , not what is return from 
  the function (as it is in useMemo) therefore funcion could be pass down in child props and execute from the child
  to be sure the child has always same function as was send to it on initial render.

      useCallback(()=&gt;fuction,[])</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const functionalCompWithInterface:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

   const [childCounter, setChildValue] = useState(); 
  //this initial state doesn t matter it will
  //be overridden from the child on first render

    const methodCalledFromChild = useCallback((value:number) =&gt; {
      //parent state is manipulate from the Child thanks to the function being locked and 
      //being able to be executed with arguements
      setChildValue(value);
  }, []);

 

  return(
    &lt;p onClick={methodCalledFromChild}&gt;{`${name} ${age}`}&lt;/p&gt;
  )
}


---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-5">
                <div class="band-inner">

                  <p>useCallback allows you to &#39;lock&#39; function based on property 
  into [dependencyArray] or call and lock once with empty array[]. This allows to pass this locked function down into the props and be 
  sure it the the same function as initial render. Just because it is the same function Child component wrapped in React.Memo(ChildCompoent)
  it will not re-render because the props have not changed.(One condition is none of the props passed down can not changed). React.Memo(ChildCompoent)
  will only re-render if props comparison will show change in props. That way we have controllable enviroment for both parent and child Compoent.</p>
                  <div class="codeWraper">
                    <code>------------------------------

------------ Parent component -----------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const Parent:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

   const [childCounter, setChildValue] = useState();  //this initial state doesn t matter it will be overridden from the child on first render

    const methodCalledFromChild = useCallback((value:number) =&gt; {
      setChildValue(value);
  }, []);

 

  return(
    &lt;p onClick={methodCalledFromChild}&gt;{`${name} ${age}`}&lt;/p&gt;
  )
}
------------ Child component -----------------------

const Child:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

    const { methodCalledFromChild } = props;

  let value = 1000;
  /*
    React.Memo(ChildComponentWithReactMemo) will stop unnecessary render 
    therefore value = 0 should be called only once. The component should not 
    re-render as long as the props stay the same;
  */

  const updateValue = () =&gt; {
    value++;
    methodCalledFromChild(value);
  };

  //initial state set for parent from the child
  methodCalledFromChild(value); //this part wont re-render so it safe it wont change

  return (
    &lt;div&gt;
      &lt;button onClick={updateValue}&gt;{&#39;Child counter&#39;}&lt;/button&gt;
    &lt;/div&gt;
  );

 

  return(
    &lt;p&gt;{`${name} ${age}`}&lt;/p&gt;
  )
}


---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-6">
                <div class="band-inner">

                  <p>useCallback allows you to &#39;lock&#39; function RETURN value based on property 
  into [dependencyArray] or called and lock only once with empty array[]. This funciton will be only called and return a value 
  if the property that is depending on will change. Remember!, here we are LOCKING THE FUNCTION WITH EXECUTION. Thefore it is useful
  for the optamization purposes when we want to perform some compuation only when propety changes.

      const complexComputation(value:number){
        //some complex mutation 
        return value + complex mutation
      }
      useMemo(()=&gt;{ return complexComputation(propertyA)},[propertyA]) 
  
  Only will perform complexComputation(value:number) when the property &#39;propertyA&#39; changes</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const functionalCompWithInterface:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

   const [counter, setCounter = useState(); 


   const complexComputation(value:number){
        //some complex mutation 
        return value + complex mutation
      }
  
  useMemo(()=&gt;{ return complexComputation(counter)},[counter]) 

  return(
    &lt;p&gt;{`${name} ${age}`}&lt;/p&gt;
  )
}

---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-7">
                <div class="band-inner">

                  <p>use effect it is a hook perfect for handling asyncrounous code, there certain rules how it should be 
    composed but the most important is the depedency array [] that wil dictate when the hook is being 
    executed. The example bellow.</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const Parent:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

   const [currentId, setCurrentId ] = useState(1); 
   const [loading, isLoaing ] = useState(false);
   const [error, setError ] = useState(null);


  useEffect(()=&gt;{
    const mockApi = async () =&gt; {
      try{
          //below doesnt need to be in depedency array cause it doesnt affect outcome of hook
          isLoading(true)

           //below HAS TO be in depedency array cause it affects outcome of hook
          const response = await get({id:currentId})

          //below doesnt need to be in depedency array cause it doesnt affect outcome of hook
          isLoading(false)

          //response set to data useState hook
          setData((prevData=&gt;Array.isArray(prevData)?[response,...prevData]:[response]))
        }
      catch(e) {
        //both dont effect 
        isLoading(false)
        hasError(e)
      }
    }
    //1. conditional call
    //this will require put &#39;error&#39; constant in dependency array cause the outcome depend on it 
    // [currentId,error]
    if(!error) mockApi()

    //2 regular call
    mockApi()
   //every time currentId changes it will cause useEffect to re-rerender
  },[currentId])

---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-8">
                <div class="band-inner">

                  <p>useEffect() comes with dependency array useEffect(()=&gt;{},[])
    1. when dependency array is empty means it will fire on componentDidMount only

    2. when is not empty it will fire every time it dependency value changes/updates

         useEffect(()=&gt;{},[data]

    3. when dependency array has object inside, React can compare values only 
    on shalow level, so for more complex object (deep nesting) We need to use the 
    trick to convert them to string or json string and then put them in 
    depedncy array</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
  locations:{[key:string]:any};
}


const Parent:React.FC&lt;FCInterfaceProps&gt; = ({name,age,locations}) =&gt; {

   const [currentId, setCurrentId ] = useState(1); 
   const [loading, isLoaing ] = useState(false);
   const [error, setError ] = useState(null);
   //this objec is has to be converted to string to avoid deep nested comparision
  const locationsJsonString = JSON.stringify(locations)



  useEffect(()=&gt;{
    const mockApi = async () =&gt; {
      try{
          //below doesnt need to be in depedency array cause it doesnt affect outcome of hook
          isLoading(true)
          //convert back to object 
          const locationsObject = JSON!.parse(locationsJsonString);


           //below HAS TO be in depedency array cause it affects outcome of hook
          const response = await get({id:currentId,locations:locationsObject})

          //below doesnt need to be in depedency array cause it doesnt affect outcome of hook
          isLoading(false)

          //response set to data useState hook
          setData((prevData=&gt;Array.isArray(prevData)?[response,...prevData]:[response]))
        }
      catch(e) {
        //both dont effect 
        isLoading(false)
        hasError(e)
      }
    }
    //1. conditional call
    //this will require put &#39;error&#39; constant in dependency array cause the outcome depend on it 
    // [currentId,error]
    if(!error) mockApi()

    //2 regular call
    mockApi()

  // location object it has been dependend on it json() version for string comparizon
  //every time currentId changes it will cause useEffect to re-rerender
  },[locationsJsonString,currentId])

---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-9">
                <div class="band-inner">

                  <p>use effect also comes with cleanup method that is executed before and after hook is being updated 
    The example below shows setTimeout() timer implementation.</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const Parent:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

   const [currentId, setCurrentId ] = useState(1); 
   const [loading, isLoaing ] = useState(false);
   const [error, setError ] = useState(null);


  useEffect(() =&gt; {
    const timer = setTimeout(() =&gt; {

      //update CurrentId on every Timeout callback
       setCurrentId((previousId) =&gt; previousId &lt; maxCalls ? previousId + 1 : previousId)

      //on every update or dismount it will remove old timer and call useEffect again 
      return () =&gt; {
        return clearTimeout(timer)
      }

    }, timeLap)
    //this useEffect will run everty time there is update to setCurrentId method
  }, [setCurrentId])

---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-10">
                <div class="band-inner">

                  <p>useRef allows you to set a value as 

    const element = useRef&lt;HTMLInputElement&gt;(null) 
  
  and then change it value by element.current = newValue. What is IMPORTANT by updating the value of element.current COMPONENT it
  WILL NOT BE re-rendered. It will update element.current without the whole compoent to be re-rendered.</p>
                  <div class="codeWraper">
                    <code>------------------------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const Parent:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

   const [toggle, toggleState = useState(true); 



  return(
    &lt;p onClick={toggleState(!toggle)}&gt;{`${name} ${age}`}&lt;/p&gt;
  )
}

---------- Child component --------------

interface FCInterfaceProps{
  name:string;
  age:number;
}
const Parent:React.FC&lt;FCInterfaceProps&gt; = ({name,age}) =&gt; {

  const renders = useRef(0) 

 console.log(&#39;renders times&#39;,renders.current++)

  //will track only renders caused by parent toggle method it wont re-render basad on renders.current variable update
  

  return(
    &lt;p&gt;{`${name} ${age}`}&lt;/p&gt;
  )
}

---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-11">
                <div class="band-inner">

                  <p>useRef allows You to set initial value useRef(1) just like useState(1) but the update to both behaves difrentlly:


      1. useRef(1) will call () =&gt; ref.current++; but U want see the change in UI since the render part is not 
      triggered ! 

      Also ref.current current value will be kept throught all updates 

      2. useState(1) will call () =&gt; setCount(c =&gt; c + 1); and on every update will re-render entire component 
      showing the current value in UI 

      Also besides if you first run () =&gt; ref.current++; and then () =&gt; setCount(c =&gt; c + 1); just because U updating 
      entire render U will also see {ref.current} updated since its execution method was previously called.</p>
                  <div class="codeWraper">
                    <code>------------------------------

const [count, setCount] = useState(1);
const ref = useRef(1);

  console.log(&#39;renders&#39;)
 
  const incCount = () =&gt; setCount(c =&gt; c + 1);
 
  const incRef = () =&gt; ref.current++;
 
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;button onClick={incCount}&gt;count: {count}&lt;/button&gt;
      &lt;hr /&gt;
      &lt;button onClick={incRef}&gt;ref.current: {ref.current}&lt;/button&gt;
    &lt;/div&gt;
  );

---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-12">
                <div class="band-inner">

                  <p>Declaration of FC in Typescript with MouseEvent</p>
                  <div class="codeWraper">
                    <code>------------------------------

const functionalCompWithInterface: React.FC= () =&gt; {

//(e:React.MouseEvent) this would be sufficient but better to be more specific

   (e:React.MouseEvent&lt;HTMLButtonElement&gt;)

  const setMe = (e:React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt;{
    setCounter(counter+1)
  }
  return (
    &lt;&gt;
      &lt;button onClick={setMe} &gt;onClick&lt;/button&gt;
   &lt;/&gt;
  );
};


---------</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-13">
                <div class="band-inner">

                  <p>Declaration of FC in Typescript with KeyboardEvent</p>
                  <div class="codeWraper">
                    <code>------------------------------

const functionalCompWithInterface: React.FC= () =&gt; {

//(e:React.KeyboardEvent) this would be sufficient but better to be more specific

   (e:React.KeyboardEvent&lt;HTMLTextAreaElement&gt;)

 const setMe = (e:React.KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt;{
    setCounter(counter+1)
  }
  return (
    &lt;&gt;
         &lt;textarea onKeyPress={setMe} /&gt;
   &lt;/&gt;
  );
};


---------</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
  
    <section class="band band-b activeSection">
      <h1></h1>

      



        

    </section>
  
  </div>
</div>

       <!-- nunjucks loop-->
  </div>
</div>
<script src="scripts/nav-links.js"></script>
<script src="scripts/tooltips_links_over.js"></script>
<script src="scripts/search_nav.js"></script>
 </body></html>