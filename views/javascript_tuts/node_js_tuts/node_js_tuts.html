<html lang="en"><head>
  <meta charset="UTF-8">  
  <title>tutorial === Layout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/tutorial.css">
  <link rel="stylesheet" href="css/tooltip.css">
</head>
<body translate="no">
<div class="l-site">
  <div class="l-nav">
    <nav class="nav">
      <input type="text" placeholder="Search" id="search">
      <div style="clear: both;"></div>
      <!-- nunjucks loop-->
            
<ul class="links">
<!--list-tag-->
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts">diffrence between exports.sth and module.exports = {}</a><span class="tooltiptext">diffrence between exports.sth and module.exports = {}</span>
                 
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts">simple express node server</a><span class="tooltiptext">simple express node server</span>
                 
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts">Express Middleware</a><span class="tooltiptext">Express Middleware</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>what is express Middleware ?</a><span class="tooltiptext">what is express Middleware ?</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>types of express Middleware</a><span class="tooltiptext">types of express Middleware</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>custom middleware</a><span class="tooltiptext">custom middleware</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>Delegating work to the Middleware (multiuse abstraction)</a><span class="tooltiptext">Delegating work to the Middleware (multiuse abstraction)</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts">express 4 routing and sub-routing</a><span class="tooltiptext">express 4 routing and sub-routing</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>register routers</a><span class="tooltiptext">register routers</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>sub-routing</a><span class="tooltiptext">sub-routing</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>combining same route in object with app.route(&#39;/..&#39;)</a><span class="tooltiptext">combining same route in object with app.route(&#39;/..&#39;)</span>
                        
                    </ul>
                
      </li>
    
      <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts">MongoDB and mongoose</a><span class="tooltiptext">MongoDB and mongoose</span>
                  
                    <ul class="linksNested">
                          
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>Define mongoDB connection and mongoose Schema</a><span class="tooltiptext">Define mongoDB connection and mongoose Schema</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>Mongoose data types</a><span class="tooltiptext">Mongoose data types</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>moongoose collection schema</a><span class="tooltiptext">moongoose collection schema</span>
                           
                          <li class="nav-primary tooltip"><a href="javascript_tuts/tuts_all_scripts_css/node_js_tuts" partition>mongoose populate ID</a><span class="tooltiptext">mongoose populate ID</span>
                        
                    </ul>
                
      </li>
    
<!--end-list-tag-->
</ul>

       <!-- nunjucks loop-->
    </nav>
  </div>
  <div class="l-page">
    <div class="menu">
      <div class="menu-hamburger"></div>
    </div>
      <!-- nunjucks loop-->
          
<div class="sectionWrapper">
  <div class="sectionContainer">
   
      
      <section  class="band band-b activeSection"  class="band band-b">
          <h1> diffrence between exports.sth and module.exports = {} </h1> 
          

            
              <div class="band-container">
                <div class="band-inner">

                  <p>module.exports = {} usually exports an object,function , once exports.sth can export anything . 
              Rules:  
                1. U can not user module.exports = {} and exports in the same file
                2. module.exports = {} can be only one in the file. As defualt export in ES6 modules.
                3. exports can be used multiple times in the file. As { named exports } in ES6 modules.</p>
                  <div class="codeWraper">
                    <code>/ --- export same object both ways ----/

  export.text1 = &#39;text1&#39;;
  export.text2 = &#39;text2&#39;;
  export.text3 = &#39;text3&#39;;

/ --- request exports ---/

  var texts = require(./texts)
  console.log(texts.text1)
  console.log(texts.text2)
  console.log(texts.text3)

/ --- same with module.exports -----/

module.exports = {
  text1: &#39;text1&#39;,
  text2: &#39;text2&#39;,
  text3: &#39;text3&#39;,
}

/ --- request exports same way---/

  var texts = require(./texts)
  console.log(texts.text1)
  console.log(texts.text2)
  console.log(texts.text3)


/----  module.export exporting a function --- /

    module.exports = function(param){}

/ --- request exports and invoke---/

    require(./function)(param)

/ --- /</code>
                  </div>
                </div>
              </div>
            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> simple express node server </h1> 
          

            
              <div class="band-container">
                <div class="band-inner">

                  <p>this is simple start up setup for node.js server with express it works on heroku as  well as localhost,
              it needs script in package.json: start:node file.js (file your sever below) it also supports ejs engine templating</p>
                  <div class="codeWraper">
                    <code>--------- server.js ----------------

var express = require(&#39;express&#39;);
var app = express();
const bodyParser = require(&#39;body-parser&#39;);
const cors = require(&#39;cors&#39;)

// process.env.PORT lets the port be set by Heroku
  var port = process.env.PORT || 8080;

// set the view engine to ejs
  app.set(&#39;view engine&#39;, &#39;ejs&#39;);

// make express look in the public directory for assets (css/js/img)
  app.use(express.static(__dirname + &#39;/public&#39;));

app.use(cors())
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))

// set the home page route
app.get(&#39;/&#39;, function(req, res) {
  //U need to specify header the bare minimum
  res.header(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)
  res.render(&#39;index&#39;);
  //res.end(&#39;hi&#39;);
});

app.get(&#39;/json&#39;, (req, res) =&gt; {
  res.header(&#39;Content-Type&#39;, &#39;application/json; charset=utf-8&#39;)
  res.json({json:&#39;it is json response object set&#39;})
})

app.listen(port, function() {
console.log(&#39;Our app is running on http://localhost:&#39; + port);
});

--------------------------------------------</code>
                  </div>
                </div>
              </div>
            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> Express Middleware </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>Express is only resposible for routing which works on top of native node moduel http. For anything else is using middleware. And middle is short 
        is just a function(req,res,next) that execute and goes to the next() middlware function until we return res.next() or any other response.</p>
                  <div class="codeWraper">
                    <code>/ ------- example middleware --------- /

app.use(function(res,req,next)=&gt;{
//do your staff and return next() when U are done!
next();
//next will go to the next middleware function
})

/--- those are the most common middleware for exprsss ---/

app.use(cors())
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))

explanation:
cors is used for non-block sameorigin http calls
bodyparser alows you to get content of http request by req.body

/------ IMPORATANT even routes are constructed as middleware function ----/

app.get(&#39;/legos&#39;),(req,res,next)=&gt;{
//posible response 
rest.send()
res.header(&#39;Content-Type&#39;, &#39;application/json; charset=utf-8&#39;)
res.render(&#39;index&#39;);

/-----   but you could also call next() if there is no res.something() already 
/-----   route is the last on the list to visit that is why it needs to responded at that point not next()

})</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>There are several types of express middleware: U can devide them into internal and third-party middleware. The order you execute your middleware
              matters as explained below:</p>
                  <div class="codeWraper">
                    <code>/ -------- /
application middleware/build-in middleware
/------/

those need to be executed first cause they are resposible for setting our static files
app.use(express.static(&#39;views&#39;))

/ -------- /
third-party middleware
/------/

those depends what they do they should be executed before certain action being detected as for bodyParser before receiving routes
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))

/ ------ /
routes 
/---- / 

U might be suprise why routes are in a middlware section?, well they are part of them when we excute route We want to respond to the browser 
as res.render(index) but we can also handle error by next(error) to be send to our error middleware 

/ ------ /
error middleware (it always needs 4 params to detect from other middleware )
/---- / 

/lets assume we have below route that triggers error

app.get(&#39;/legos&#39;),(req,res,next)=&gt;{
  next(new Error(&#39;no way!&#39;))
})
  app.use(function(err,res,req,next)=&gt;{
  //handle error
  console.log(error)
  //do your staff and return next() when U are done!
  next();
})

/------/</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>the beauty of middleware is the fact that is just a function! so we can easily make custom ones to serve our purpose in a middlware chain.</p>
                  <div class="codeWraper">
                    <code>/ ---- /
  custom middleware request it is with a dot adnotation so node recognize it as custom note a module from node_modules;
/ ----/

car customMiddlware = require(&#39;./custom&#39;)

/---- quite often our custom middleware is wrapped in higher order functio to pass some params ---/

const custom = (param)=&gt;{
  return fuction(req,res,next){
  //do something 
  next()
  //move on to the next one...
  }
}

/---- execute custom middleware ----/

app.get(&#39;/legos&#39;, custom(param), function(req,res,)=&gt;{
  res.render(&#39;I am cool now!&#39;)
})

explanation:
the custom midllware could be execute on route level, so the application gets to route and then executes the stack of middlware
on this level it could take fuctions or array of functions

app.get(&#39;/legos&#39;, custom(param),custom1(param), function(req,res,)=&gt;{})

stack = [custom(param),custom1(param)];
app.get(&#39;/legos&#39;, stack, function(req,res,)=&gt;{})


/ ---- /</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-4">
                <div class="band-inner">

                  <p>Express comes with some helper middleware as app.param that alows you to do some logic outsite the route and then give you the result back in route</p>
                  <div class="codeWraper">
                    <code>/--- let say U got route as one below ----/

/----
now every time we hit any route with id as &#39;legos/:i d&#39; or &#39;lions/lion/:id&#39; 
express can delegate what we can do with id in a seperate middlware 
 ----\

app.param(&#39;id&#39;, function(req,res,next){
  //do something with id
  next()
  //move on to next
})

/--- this route has to be after app.param --/
app.use(&#39;legos/:id&#39;,function(req,res){})

/--/</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> express 4 routing and sub-routing </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>express 4.&gt; allows you to register more that one router which a milestone from express 3. that hold everthing on app.router() level.</p>
                  <div class="codeWraper">
                    <code>/ ---- regiser routets  ----/

var toDoListRouter = express.Router();
var guesscheckoutRouter = express.Router();

//now regiester them with the main app express;
app.use(&#39;/toDoListRouter&#39;,loginRouter)
app.use(&#39;/guesscheckout&#39;,guesscheckoutRouter)

explanation:
app.use(&#39;/guesscheckout&#39;,guesscheckoutRouter) middleware allows to delegate the work of handling any /guesscheckout/...
routes to the guesscheckoutRouter middleware

/-----/</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>sub-routing allow you to create addtional routes that derived from master route as app.get(/masterPath/)</p>
                  <div class="codeWraper">
                    <code>/---- register our route with main app and delegate any /guesscheckout/additionalpath to loginRouter path ---/

app.use(&#39;/guesscheckout&#39;,guesscheckout)


/ ---- sub-routes to /guesscheckout path -----/

guesscheckout.get(&#39;/&#39;,function(req,res){
//this routes corresponds to /guesscheckout/ === /guesscheckout
res.render(&#39;..ok I will do it&#39;)}
)
guesscheckout.get(&#39;/:id&#39;,function(req,res){
 //this routes corresponds to /guesscheckout/:id 
res.render(&#39;..yeah I am a guest !&#39;)
})

info:
sub-routing are great for organizing, abstracting away your routes and put them in seperate file and simple export to require them in main server file:
module.exports = guesscheckout

 /----/</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>lets say We have app.get(&#39;/lions&#39;) and then we have app.post(&#39;/lions&#39;), we can put them in one place...</p>
                  <div class="codeWraper">
                    <code>/ ------ request on the same route as: -----/

app.get(&#39;/lions&#39;,(req,res)=&gt;{})
app.post(&#39;/lions&#39;(req,res)=&gt;{})

/ --- use app.route() to put them together --/

app.route(&#39;/lions&#39;)
.get(&#39;/lions&#39;,(req,res)=&gt;{})
.post(&#39;/lions&#39;(req,res)=&gt;{})

/-----/</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
      
      <section   class="band band-b" class="band band-b">
          <h1> MongoDB and mongoose </h1> 
          
              <div class="band-container partition first" part="part-1">
                <div class="band-inner">

                  <p>MongoDB is noSQL database , that is just a giant object that would exept any data without any validation. It needs 
              3th party products to make sure the data is set according the data models schema and is valid.</p>
                  <div class="codeWraper">
                    <code>/----- example mongoDb connection in node.js ---/

/ -----   /
var mongoose = require(&#39;mongoose&#39;);
var url = &quot;mongodb://localhost:27017/mydb&quot;;
mongoose.connect(&#39;mongodb://localhost:27017/myapp&#39;, {useNewUrlParser: true});
/ -----   /
explanation:
mongodb://localhost:27017/myapp =&gt; where myApp is name of DB that is running on localhost PORT:27017
practically, If U plan to publish your app is better to set up your DB on host domain as myLAB for heroku

/ -----   /</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-2">
                <div class="band-inner">

                  <p>Moongoose allows U to make schema therfore comes with some extra data types to make that happen.</p>
                  <div class="codeWraper">
                    <code>/ ----------- /
  Sample data type are:
  String,
  Number,
  Boolean,
  Object,
  Array,
  OBjectId, (this is reference to other model)
Date,
/ ------ /</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-3">
                <div class="band-inner">

                  <p>mongoose allows U to crate schema for every collection you make in mongoDB making sure the data pass in is correct</p>
                  <div class="codeWraper">
                    <code>/ ---   example mongoose schema ------/


var PostSchema = {
  title:{
    type:String,
    required:true,
    unique:true
  }
  text:{
    type:String,
    required:true
    }
  author:{
    type:Shema.Types.ObjectId
    ref:&#39;user&#39;
  }
  categories:[
    {
    type:Shema.Types.ObjectId
    ref:&#39;category&#39;
  }]
}

/---- the possible post could be: ----/
&quot;posts&quot;:{
  &quot;title&quot;: &quot;Life of PI&quot;
  &quot;text&quot;: &quot;Aparently is a great book and movie!&quot;
  author: &quot;ObjectId(436353453535353e423d)&quot;
  categories:[
      &quot;ObjectId(4r554353453535353e423d)&quot;,
      &quot;ObjectId(43336353453535353e423d)&quot;
      &quot;ObjectId(55555353453535353e423d)&quot;
  ]
}

explanation:
Post model has PostSchema that has fields: title, text, author, categories.
Notice that author and categories are diffrent: 
author is referenced in user Model with its ID.
categories are in array referenced in category Model by its IDs. so we dont bring categories name here if we want to access
them We would use their ids and fields set in Category Model. Therefore is so important to use GUI interface for choosing
reference type data to not make it mistake. Dont update them in code unless you know every category unique ID reference.</code>
                  </div>
                </div>
              </div>
            
              <div class="band-container partition " part="part-4">
                <div class="band-inner">

                  <p>It is possible to save the record without ObjectID in one of the fields and populate that field later in another post Query</p>
                  <div class="codeWraper">
                    <code>/ --- / 
check if the field is populated ?

post.populated(&#39;author&#39;); // truthy 

/ -- /

What about creating a post ?

/---- the possible post could be: ----/
  &quot;posts&quot;:{
    &quot;title&quot;: &quot;Life of PI&quot;
    &quot;text&quot;: &quot;Aparently is a great book and movie!&quot;
    //author: NOT ADDED
    categories:[
        &quot;ObjectId(4r554353453535353e423d)&quot;,
        &quot;ObjectId(43336353453535353e423d)&quot;
        &quot;ObjectId(55555353453535353e423d)&quot;
    ]
  }

explanation:
just because athour is not required and not unique field we can save our post without it. But that means we just created a post
who doesnt have an author. There are at least 2 wasy to fix that. 

1. use populate method as

  Post.
    findOne({ title: &#39;Casino Royale&#39; })
    .populate(&#39;author&#39;)
    .exec(function (err, story) {
      if (err) return handleError(err);
      console.log(&#39;The author is %s&#39;, story.author.name);
      // prints &quot;The author is Ian Fleming&quot;
    });
This will look for Post title and populate with the ID of the only Author in collection. ONLY one is fine but what if there is more authors?
well then will go crazy. The moongoose documentation says this: &#39;If you have an array of authors in your storySchema, populate() will give you an empty array instead.&#39; so unless U have only one author then will work otherwise dont use populate!

2. Another way of filling the author fiels is to grab current author ID and pass it in POST Query as merge object {author:ObjectID(83t34t),...rest} that way
we fill it right when post in created with the author that is logged in.</code>
                  </div>
                </div>
              </div>
            

            

      </section>
  
  
    <section class="band band-b activeSection">
      <h1></h1>

      



        

    </section>
  
  </div>
</div>

       <!-- nunjucks loop-->
  </div>
</div>
<script src="scripts/nav-links.js"></script>
<script src="scripts/tooltips_links_over.js"></script>
<script src="scripts/search_nav.js"></script>
 </body></html>